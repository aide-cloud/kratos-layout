// Code generated by github.com/aide-cloud/protoc-gen-go-gin. DO NOT EDIT.

package v1

import (
	context "context"
	gin "github.com/gin-gonic/gin"
	binding "github.com/gin-gonic/gin/binding"
	metadata "google.golang.org/grpc/metadata"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the mohuishou/protoc-gen-go-gin package it is being compiled against.
// context.metadata.
// gin.binding.

type PingGinHTTPServerResponse interface {
	Success(c *gin.Context, data interface{})
	Failed(c *gin.Context, err error)
}

type PingGinHTTPServerBind interface {
	Bind(c *gin.Context, params interface{}) error
}

type PingGinHTTPServer interface {
	Ping(context.Context, *PingRequest) (*PingResponse, error)
}

type Ping struct {
	server PingGinHTTPServer
	router gin.IRouter
	bind   PingGinHTTPServerBind
	resp   PingGinHTTPServerResponse
}

type PingOption func(*Ping)

type defaultPingGinHTTPServerBind struct{}

type defaultPingGinHTTPServerResponse struct{}

func (*defaultPingGinHTTPServerBind) Bind(c *gin.Context, params interface{}) error {
	b := binding.Default(c.Request.Method, c.ContentType())
	if err := c.ShouldBindWith(params, b); err != nil {
		return err
	}

	if err := binding.Form.Bind(c.Request, params); err != nil {
		return err
	}

	if err := c.ShouldBindUri(params); err != nil {
		return err
	}

	if err := c.ShouldBindHeader(params); err != nil {
		return err
	}

	return nil
}

func (*defaultPingGinHTTPServerResponse) Success(c *gin.Context, data interface{}) {
	c.JSON(200, data)
}

func (*defaultPingGinHTTPServerResponse) Failed(c *gin.Context, err error) {
	if err == nil {
		c.AbortWithStatus(500)
		return
	}
	c.JSON(500, err.Error())
}

func NewPing(server PingGinHTTPServer, opts ...PingOption) *Ping {
	s := &Ping{
		server: server,
		bind:   &defaultPingGinHTTPServerBind{},
		resp:   &defaultPingGinHTTPServerResponse{},
	}
	for _, opt := range opts {
		if opt != nil {
			opt(s)
		}
	}
	return s
}

func WithRouter(router gin.IRouter) PingOption {
	return func(s *Ping) {
		s.router = router
	}
}

func WithBind(bind PingGinHTTPServerBind) PingOption {
	return func(s *Ping) {
		s.bind = bind
	}
}

func WithResponse(resp PingGinHTTPServerResponse) PingOption {
	return func(s *Ping) {
		s.resp = resp
	}
}

func RegisterPingGinHTTPServer(server *Ping) {
	server.RegisterService()
}

func (s *Ping) Ping_0(ctx *gin.Context) {
	var in PingRequest
	if err := s.bind.Bind(ctx, &in); err != nil {
		s.resp.Failed(ctx, err)
		return
	}

	md := metadata.New(nil)
	for k, v := range ctx.Request.Header {
		md.Set(k, v...)
	}
	newCtx := metadata.NewIncomingContext(ctx, md)
	out, err := s.server.(PingGinHTTPServer).Ping(newCtx, &in)
	if err != nil {
		s.resp.Failed(ctx, err)
		return
	}

	s.resp.Success(ctx, out)
}

func (s *Ping) RegisterService() {

	s.router.Handle("GET", "/ping", s.Ping_0)

}
